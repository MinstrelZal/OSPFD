#ifndef _AREA_H
#define _AREA_H

#include "interface.h"
#include "shared.h"

#include <netinet/in.h>

struct interface_data;

/* 16.1. Calculating the shortest-path tree for an area */
/* This calculation yields the set of intra-area routes associated
   with an area (called hereafter Area A). A router calculates the
   shortest-path tree using itself as the root.[22] The formation
   of the shortest path tree is done here in two stages. In the
   first stage, only links between routers and transit networks are
   considered. Using the Dijkstra algorithm, a tree is formed from
   this subset of the link state database. In the second stage,
   leaves are added to the tree by considering the links to stub
   networks.

   The procedure will be explained using the graph terminology that
   was introduced in Section 2. The area’s link state database is
   represented as a directed graph. The graph’s vertices are
   routers, transit networks and stub networks. The first stage of
   the procedure concerns only the transit vertices (routers and
   transit networks) and their connecting links. Throughout the
   shortest path calculation, the following data is also associated
   with each transit vertex: */

typedef struct vertex{
	/* Vertex (node) ID
       A 32-bit number which together with the vertex type (router
       or network) uniquely identifies the vertex. For router
       vertices the Vertex ID is the router’s OSPF Router ID. For
       network vertices, it is the IP address of the network’s
       Designated Router. */
	in_addr_t id;
	in_addr_t network_mask;

	/* An LSA
       Each transit vertex has an associated LSA. For router
       vertices, this is a router-LSA. For transit networks, this
       is a network-LSA (which is actually originated by the
       network’s Designated Router). In any case, the LSA’s Link
       State ID is always equal to the above Vertex ID. */
	const ospf_lsa_header *lsa;

	/* List of next hops
       The list of next hops for the current set of shortest paths
       from the root to this vertex. There can be multiple
       shortest paths due to the equal-cost multipath capability.
       Each next hop indicates the outgoing router interface to use
       when forwarding traffic to the destination. On broadcast,
       Point-to-MultiPoint and NBMA networks, the next hop also
       includes the IP address of the next router (if any) in the
       path towards the destination. */
	in_addr_t next_hop;

	/* Distance from root
       The link state cost of the current set of shortest paths
       from the root to the vertex. The link state cost of a path
       is calculated as the sum of the costs of the path’s
       constituent links (as advertised in router-LSAs and
       network-LSAs). One path is said to be "shorter" than
       another if it has a smaller link state cost. */
	uint16_t dist;
}vertex;

/* 6. The Area Data Structure */
/* The area data structure contains all the information used to run the
   basic OSPF routing algorithm. Each area maintains its own link-state
   database. A network belongs to a single area, and a router interface
   connects to a single area. Each router adjacency also belongs to a
   single area.

   The OSPF backbone is the special OSPF area responsible for
   disseminating inter-area routing information.

   The area link-state database consists of the collection of router-
   LSAs, network-LSAs and summary-LSAs that have originated from the
   area’s routers. This information is flooded throughout a single
   area only. The list of AS-external-LSAs (see Section 5) is also
   considered to be part of each area’s link-state database. */

typedef struct area_addr{
	in_addr_t address;
	in_addr_t network_mask;
	int state;
}area_addr;

typedef struct area{
	/* Area ID - A 32-bit number identifying the area. The Area ID of 0.0.0.0 is
       reserved for the backbone. */
	uint32_t id;

	/* List of area address ranges - 
	   In order to aggregate routing information at area boundaries,
	   area address ranges can be employed. Each address range is
	   specified by an [address,mask] pair and a status indication of
	   either Advertise or DoNotAdvertise (see Section 12.4.3). */
	int num_area;
	area_addr area_addr_range[LIST_MAX];

	/* Associated router interfaces - 
	   This router’s interfaces connecting to the area. A router
	   interface belongs to one and only one area (or the backbone).
	   For the backbone area this list includes all the virtual links.
	   A virtual link is identified by the Router ID of its other
	   endpoint; its cost is the cost of the shortest intra-area path
	   through the Transit area that exists between the two routers. */
	int num_if;
	struct interface_data *ifs[MAX_IF_PER_AREA];

	/* List of router-LSAs - 
       A router-LSA is generated by each router in the area. It
       describes the state of the router’s interfaces to the area. */
	// int num_router_lsa;
	// struct ospf_lsa_header *rlsas[LIST_MAX];

	/* List of network-LSAs - 
	   One network-LSA is generated for each transit broadcast and NBMA 
	   network in the area. A network-LSA describes the set of routers
	   currently connected to the network. */
	// int num_network_lsa;
	// struct ospf_lsa_header *nlsas[LIST_MAX];

	/* List of summary-LSAs - 
	   Summary-LSAs originate from the area’s area border routers.
	   They describe routes to destinations internal to the Autonomous
	   System, yet external to the area (i.e., inter-area
	   destinations). */
	// int num_summary_lsa;
	// struct ospf_lsa_header *slsas[LIST_MAX];
	
	int num_lsa;
	ospf_lsa_header *lsas[LIST_MAX];

	/* Shortest-path tree - 
	   The shortest-path tree for the area, with this router itself as
	   root. Derived from the collected router-LSAs and network-LSAs
	   by the Dijkstra algorithm (see Section 16.1). */
	int num_vertex;
	vertex vertices[NUM_VERTEX];

	/* TransitCapability - 
	   This parameter indicates whether the area can carry data traffic
	   that neither originates nor terminates in the area itself. This
	   parameter is calculated when the area’s shortest-path tree is
	   built (see Section 16.1, where TransitCapability is set to TRUE
	   if and only if there are one or more fully adjacent virtual
	   links using the area as Transit area), and is used as an input
	   to a subsequent step of the routing table build process (see
	   Section 16.3). When an area’s TransitCapability is set to TRUE,
	   the area is said to be a "transit area". */
	int transit_capability;

	/* ExternalRoutingCapability - 
	   Whether AS-external-LSAs will be flooded into/throughout the
	   area. This is a configurable parameter. If AS-external-LSAs
	   are excluded from the area, the area is called a "stub". Within
	   stub areas, routing to AS external destinations will be based
	   solely on a default summary route. The backbone cannot be
	   configured as a stub area. Also, virtual links cannot be
	   configured through stub areas. For more information, see
	   Section 3.6. */
	int external_routing_capability;

	/* StubDefaultCost - 
	   If the area has been configured as a stub area, and the router
	   itself is an area border router, then the StubDefaultCost
	   indicates the cost of the default summary-LSA that the router
	   should advertise into the area. See Section 12.4.3 for more
	   information. */
	uint16_t stub_default_cost;
}area;

area *lookup_area_by_if(const struct interface_data *iface);
int lookup_vertex_by_id(area *a, in_addr_t id);
area *lookup_area_by_id(uint32_t area_id);
area *area_init(uint32_t area_id);
void add_area_ifs(area *a, struct interface_data *iface);
int lookup_least_cost_vertex(area *a);
int lookup_least_cost_vertex_by_id(area *a, in_addr_t id);

#endif
